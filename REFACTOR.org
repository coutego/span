#+title: Refactor Design & Architecture

* Architecture Overview: Unidirectional Data Flow
The package will be refactored to follow a strict "Elm/Redux" style architecture.
The application state is immutable. User input triggers a state transition, which triggers a full UI redraw.

** The Cycle
1. **State:** A single struct holds the entire state of the application (Current date, list of events, currently selected item ID, etc.).
2. **Render:** A pure function takes the State and draws the buffer.
3. **Input:** User presses a key.
4. **Update:** A function takes (State, Input) and returns (New State).
5. **Effect:** If the State changed, persist to disk and GOTO step 2.

* Layer Breakdown

** 1. Persistence Layer (FS)
- **Responsibility:** Pure I/O. Reading and writing S-expressions to files.
- **No Logic:** It does not know what an "event" is, only that it is a list of Lisp objects.
- **Functions:**
  - `(chronos-fs-read date) -> list-of-sexps`
  - `(chronos-fs-write date list-of-sexps) -> nil`

** 2. Domain Layer (Core Logic)
- **Responsibility:** Business logic. Event Sourcing implementation.
- **Data Structures:** `Event`, `Interval`.
- **Purity:** 100% Pure functions. No side effects.
- **Functions:**
  - `(chronos-add-event events type payload) -> new-events-list`
  - `(chronos-reduce-events events) -> day-view-model` (Calculates intervals, gaps, active task).
  - `(chronos-split-interval events interval split-time) -> new-events-list`

** 3. Application State Layer (The Store)
- **Responsibility:** Holding the transient state of the editor.
- **Structure:**
  #+begin_src elisp
  (cl-defstruct chronos-state
    date           ; ts-struct
    events         ; list of raw events
    view-model     ; computed intervals (cached for rendering)
    selected-id    ; UUID of the currently selected row in UI
    last-message   ; Status message to show
    )
  #+end_src

** 4. UI Layer (The Renderer)
- **Decision: Drop `magit-section`.**
  - **Reasoning:** `magit-section` maintains its own internal state (folding, cursor position). In a "redraw-on-change" architecture, syncing Magit's state with our App State is painful and brittle.
  - **New Approach:** Custom "Game Loop" rendering.
- **Mechanism:**
  1. `erase-buffer`
  2. Insert Header (Date, Summary).
  3. Loop through `view-model` intervals.
  4. Insert each line.
  5. **Selection:** If `interval.id == state.selected-id`, apply a specific face (background color) to the whole line.
- **Benefits:**
  - "Row Selection" instead of "Cursor Position".
  - We can use `overlay` or `text-properties` with `(:extend t)` to highlight the full width of the row.
  - Navigation (`j`/`k`) simply updates `state.selected-id` and triggers a redraw. We don't move the Emacs point manually.

** 5. Controller Layer (Input)
- **Responsibility:** Mapping keybindings to State Transitions.
- **Functions:**
  - `(chronos-cmd-next-row)`: Updates `selected-id` to the next interval in the list.
  - `(chronos-cmd-clock-in)`: Reads `selected-id`, prompts user, calls Domain Layer to add event, updates State, triggers Save & Render.

* Testing Strategy

** 1. Domain Layer (Unit Tests)
- **Goal:** Verify business logic correctness without Emacs UI or File System.
- **Tools:** `ert` (Emacs Lisp Regression Testing).
- **Scenarios:**
  - **Reduction:** Given a list of raw events (Start, Switch, Stop), verify `chronos-reduce-events` produces the correct list of Intervals with correct durations.
  - **Gaps:** Verify that missing time between a Stop and a Start is correctly identified as a `:gap` interval.
  - **Active Task:** Verify that if the last event is a Start, the reducer produces an open-ended Active Interval.
  - **Splitting:** Given an event list and a split time, verify the new list contains the correct inserted event and sorted order.
  - **Merging/Deletion:** Verify removing an event correctly merges the time into the adjacent interval.

** 2. State Layer (Integration Tests)
- **Goal:** Verify state transitions.
- **Tools:** `ert`.
- **Scenarios:**
  - **Navigation:** Call `(chronos-cmd-next-row)` on a mock state. Verify `selected-id` updates to the ID of the next interval.
  - **Date Change:** Call `(chronos-cmd-next-day)`. Verify `date` updates and `events` are cleared (or loaded from mock).
  - **Selection Stability:** Verify that after a reload/refresh, if the previously selected ID still exists, it remains selected.

** 3. Persistence Layer (IO Tests)
- **Goal:** Verify serialization.
- **Tools:** `ert` with `make-temp-file`.
- **Scenarios:**
  - **Round Trip:** Write a list of complex events (with plists and strings) to a temp file. Read it back. Assert equality.
  - **Corruption:** Write a malformed line. Verify the reader handles it gracefully (e.g., skips or errors safely).

** 4. UI Layer (Snapshot/Render Tests)
- **Goal:** Verify the buffer looks correct for a given state.
- **Tools:** `ert` with `with-temp-buffer`.
- **Scenarios:**
  - **Rendering:**
    1. Create a mock `chronos-state` with specific events.
    2. Call the render function in a temp buffer.
    3. Assert the buffer string contains expected substrings (e.g., "09:00 - 10:00", "Task Title").
    4. Assert text properties (faces) are applied to the selected row.

* Implementation Plan

1. **Define the State Struct:** Create the container for the application.
2. **Port Domain Logic:** Ensure `org-chronos-core.el` functions are pure and accept/return lists, not reading from disk.
3. **Build the Renderer:** Create the function that draws the buffer from the State struct (without Magit).
4. **Build the Controller:** Wire up `j`/`k` to change the selection in the State and redraw.
5. **Wire Persistence:** Ensure actions that modify `events` in the State also trigger a write to disk.
